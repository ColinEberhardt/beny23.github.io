<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>scala on Tales about Software Engineering</title><link>https://beny23.github.io/tags/scala/</link><description>Recent content in scala on Tales about Software Engineering</description><generator>Hugo -- gohugo.io</generator><language>en-gb</language><copyright>Software Design Systems</copyright><lastBuildDate>Sat, 30 May 2020 10:29:17 +0100</lastBuildDate><atom:link href="https://beny23.github.io/tags/scala/index.xml" rel="self" type="application/rss+xml"/><item><title>One million records in 15 seconds</title><link>https://beny23.github.io/posts/one_million_records_in_15s/</link><pubDate>Sat, 30 May 2020 10:29:17 +0100</pubDate><guid>https://beny23.github.io/posts/one_million_records_in_15s/</guid><description>In this post, I&amp;rsquo;d like to talk about optimisations that I recently used to provide a Scala Microservice that surfaced payment events. The events were held in an Oracle backend and the Microservice was in a docker container with (1 vCPU) allocated 512MB to the container and 256MB to the JVM that was running it. In this writing I&amp;rsquo;m not going to talk about the Oracle optimisations to make the underlying query fly but rather would like to concentrate on the kinds of things that can make service code quick.</description></item></channel></rss>